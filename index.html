<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>å…ƒç¥–BanG Dream!Chan åå®¹é“å°æ¸¸æˆ</title>
    <meta name="description" content="å…ƒç¥–è¿·ä½ åŠ¨ç”»å°æ¸¸æˆå¤åˆ»" />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: #4a6741;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        font-family: "Segoe UI", "Microsoft YaHei", sans-serif;
        user-select: none;
        -webkit-user-select: none;
        overflow: hidden;
      }

      #game-wrapper {
        position: relative;
      }

      #game-wrapper img.board-bg {
        display: block;
        width: 960px;
        height: 540px;
        pointer-events: none;
        transition: opacity 0.3s ease;
      }

      #board {
        position: absolute;
        top: 4.8%;
        left: 25.3%;
        width: 49.5%;
        height: 89.5%;
        overflow: hidden;
      }

      .block {
        position: absolute;
        cursor: grab;
        transition:
          left 0.18s ease-out,
          top 0.18s ease-out;
        border-radius: 6px;
        overflow: hidden;
        z-index: 1;
      }

      .block.dragging {
        transition: none;
        cursor: grabbing;
        z-index: 50;
        filter: brightness(1.05);
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
      }

      .block:hover {
        z-index: 10;
        filter: brightness(1.08);
      }

      .block:active {
        cursor: grabbing;
      }

      .block img {
        width: 100%;
        height: 100%;
        display: block;
        object-fit: cover;
        pointer-events: none;
      }

      /* æ§åˆ¶é¢æ¿ â€” å³ä¾§ */
      #control-panel {
        position: absolute;
        top: 50%;
        right: 2%;
        transform: translateY(-50%);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        z-index: 20;
        background: rgba(0, 0, 0, 0.3);
        padding: 15px 10px;
        border-radius: 20px;
        backdrop-filter: blur(2px);
      }

      #round-setup {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
        margin-bottom: 5px;
        width: 100%;
      }

      #round-setup label {
        color: #f0d89f;
        font-size: 12px;
        font-weight: bold;
        text-shadow: 1px 1px 2px black;
      }

      #total-rounds-input {
        width: 70px;
        padding: 4px;
        text-align: center;
        background: rgba(0, 0, 0, 0.7);
        border: 2px solid #e8b74a;
        color: #e8b74a;
        font-weight: bold;
        border-radius: 20px;
        outline: none;
        font-size: 16px;
      }

      #set-rounds-btn {
        background: #e8b74a;
        border: none;
        color: #1a1a1a;
        font-weight: bold;
        padding: 4px 12px;
        border-radius: 20px;
        cursor: pointer;
        font-size: 12px;
        transition: all 0.2s;
        margin-top: 2px;
      }

      #set-rounds-btn:hover {
        background: #ffd966;
        transform: scale(1.05);
      }

      #round-display {
        color: #f0d89f;
        font-size: 18px;
        font-weight: bold;
        background: rgba(0, 0, 0, 0.5);
        padding: 6px 16px;
        border-radius: 30px;
        border: 1px solid #e8b74a;
        margin-bottom: 5px;
        letter-spacing: 1px;
      }

      #step-label {
        color: #c4a96a;
        font-size: 14px;
        font-weight: bold;
        letter-spacing: 1px;
      }

      #step-display {
        color: #e8b74a;
        font-size: 52px;
        font-weight: 900;
        font-family: "Courier New", monospace;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        line-height: 1;
      }

      .btn {
        padding: 8px 20px;
        border: 2px solid #e8b74a;
        background: rgba(0, 0, 0, 0.6);
        color: #e8b74a;
        font-size: 14px;
        font-weight: bold;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s;
        white-space: nowrap;
        font-family: "Microsoft YaHei", sans-serif;
        width: 90px;
        text-align: center;
      }

      .btn:hover {
        background: #e8b74a;
        color: #1a1a1a;
      }

      .btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }

      /* Victory overlay */
      #victory-overlay {
        display: none;
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.75);
        z-index: 300;
        justify-content: center;
        align-items: center;
        animation: fadeIn 0.3s ease;
      }

      #victory-overlay.show {
        display: flex;
      }

      #victory-box {
        background: linear-gradient(135deg, #ff6b9d, #c44569);
        border: 4px solid #fff;
        border-radius: 20px;
        padding: 40px 50px;
        text-align: center;
        color: #fff;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        animation: popIn 0.4s cubic-bezier(0.18, 0.89, 0.32, 1.28);
      }

      #victory-box h2 {
        font-size: 36px;
        margin-bottom: 10px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }

      #victory-box p {
        font-size: 20px;
        margin-bottom: 8px;
        opacity: 0.9;
      }

      #victory-box .btn {
        font-size: 16px;
        padding: 10px 28px;
        border-color: #fff;
        color: #fff;
        background: rgba(255, 255, 255, 0.15);
        width: auto;
        margin-top: 16px;
      }

      #victory-box .btn:hover {
        background: #fff;
        color: #c44569;
      }

      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }

      @keyframes popIn {
        from { transform: scale(0.5); opacity: 0; }
        to { transform: scale(1); opacity: 1; }
      }

      /* ===== ä»“åº“é“¾æ¥åŒºåŸŸ - å·¦ä¸‹è§’ï¼Œå¢åŠ éŸ³æ•ˆå¼€å…³ ===== */
      .repo-links {
        position: absolute;
        bottom: 8px;
        left: 2%;
        z-index: 200;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      /* éŸ³æ•ˆå¼€å…³æ ·å¼ */
      .sound-toggle {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 6px 12px;
        background: rgba(0, 0, 0, 0.6);
        border: 1.5px solid rgba(255, 255, 255, 0.2);
        border-radius: 20px;
        color: #fff;
        font-size: 13px;
        font-weight: 600;
        backdrop-filter: blur(6px);
        white-space: nowrap;
        margin-bottom: 2px;
        transition: all 0.25s ease;
      }

      .sound-toggle:hover {
        background: rgba(255, 255, 255, 0.15);
        border-color: #e8b74a;
      }

      .sound-toggle input[type="checkbox"] {
        width: 16px;
        height: 16px;
        cursor: pointer;
        accent-color: #e8b74a;
        transform: scale(1.1);
        margin-right: 4px;
      }

      .sound-toggle label {
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 4px;
        color: inherit;
      }

      .repo-link {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 8px 16px;
        background: rgba(0, 0, 0, 0.6);
        border: 1.5px solid rgba(255, 255, 255, 0.2);
        border-radius: 20px;
        color: #fff;
        font-size: 13px;
        font-weight: 600;
        text-decoration: none;
        font-family: "Segoe UI", "Microsoft YaHei", sans-serif;
        transition: all 0.25s ease;
        backdrop-filter: blur(6px);
        white-space: nowrap;
      }

      .repo-link:hover {
        background: rgba(255, 255, 255, 0.15);
        border-color: #e8b74a;
        color: #e8b74a;
        transform: scale(1.05);
      }

      .repo-link svg {
        width: 18px;
        height: 18px;
        fill: currentColor;
      }

      .repo-link .star-icon {
        width: 14px;
        height: 14px;
      }

      .original-badge {
        background: #8b6e4b;
        color: #ffd966;
        font-size: 10px;
        padding: 2px 6px;
        border-radius: 12px;
        margin-left: 6px;
        font-weight: normal;
        border: 1px solid #e8b74a;
      }

      .fork-link {
        border-color: #6b8e4b;
      }

      .fork-link:hover {
        border-color: #a5d6a5;
        color: #a5d6a5;
      }

      .bili-link {
        border-color: #fb7299;
      }

      .bili-link:hover {
        border-color: #ffa0c0;
        color: #ffa0c0;
        box-shadow: 0 0 15px #fb7299, 0 0 30px #fb7299;
        transition: all 0.3s ease;
      }

      .bili-link svg.play-icon {
        width: 16px;
        height: 16px;
      }

      /* Responsive */
      @media (max-width: 780px) {
        #game-wrapper img.board-bg {
          width: 100vw;
          height: auto;
        }
        #control-panel {
          position: absolute;
          top: auto;
          bottom: -50px;
          right: 50%;
          transform: translateX(50%);
          flex-direction: row;
          gap: 8px;
          background: transparent;
          backdrop-filter: none;
        }
        #round-setup {
          flex-direction: row;
          width: auto;
        }
        #step-label {
          display: none;
        }
        #step-display {
          font-size: 28px;
        }
        .btn {
          font-size: 13px;
          padding: 6px 14px;
          width: auto;
        }
        .repo-links {
          gap: 4px;
          bottom: 8px;
          left: 1%;
        }
        /* éŸ³æ•ˆå¼€å…³åœ¨ç§»åŠ¨ç«¯æ˜¾ç¤ºä¸ºç´§å‡‘æ ·å¼ */
        .sound-toggle {
          padding: 4px 8px;
          font-size: 12px;
        }
        .sound-toggle input[type="checkbox"] {
          width: 14px;
          height: 14px;
        }
        .repo-link {
          padding: 6px;
          border-radius: 50%;
        }
        .repo-link svg:first-child {
          width: 16px;
          height: 16px;
        }
        .repo-link .star-icon,
        .repo-link .star-text,
        .original-badge {
          display: none;
        }
        .fork-link .star-text {
          display: none;
        }
        .bili-link .star-text {
          display: none;
        }
      }
    </style>
  </head>
  <body>
    <div id="game-wrapper">
      <img class="board-bg" id="board-bg-img" src="images/board1.png" alt="æ£‹ç›˜èƒŒæ™¯" />

      <!-- ä»“åº“é“¾æ¥åŒºåŸŸï¼šå·¦ä¸‹è§’ï¼Œå¢åŠ EveéŸ³æ•ˆå¼€å…³ -->
      <div class="repo-links">
        <!-- éŸ³æ•ˆå¼€å…³ -->
        <div class="sound-toggle">
          <label>
            <input type="checkbox" id="eve-sound-toggle" checked> "æ­¦å£«é“ï¼"
          </label>
        </div>

        <!-- åŸä»“åº“é“¾æ¥ï¼ˆå¸¦â€œåŸä½œä»“åº“â€æ ‡ç­¾ï¼‰ -->
        <a
          class="repo-link"
          href="https://github.com/fflow2023/BanGKlotski"
          target="_blank"
          rel="noopener"
          title="åŸä»“åº“"
        >
          <svg viewBox="0 0 16 16">
            <path
              d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"
            />
          </svg>
          <svg class="star-icon" viewBox="0 0 16 16">
            <path
              d="M8 .25a.75.75 0 0 1 .673.418l1.882 3.815 4.21.612a.75.75 0 0 1 .416 1.279l-3.046 2.97.719 4.192a.75.75 0 0 1-1.088.791L8 12.347l-3.766 1.98a.75.75 0 0 1-1.088-.79l.72-4.194L.818 6.374a.75.75 0 0 1 .416-1.28l4.21-.611L7.327.668A.75.75 0 0 1 8 .25z"
            />
          </svg>
          <span class="star-text"></span>
          <span class="original-badge">åŸä½œä»“åº“</span>
        </a>

        <!-- ä¼˜åŒ–ç‰ˆ fork é“¾æ¥ï¼ˆå·²é…ç½®ä¸ºæ‚¨çš„åœ°å€ï¼‰ -->
        <a
          class="repo-link fork-link"
          href="https://github.com/KasumiAmi/BanGKlotski_Enhanced"
          target="_blank"
          rel="noopener"
          title="ä¼˜åŒ–ç‰ˆä»“åº“é“¾æ¥"
        >
          <svg viewBox="0 0 16 16">
            <path
              d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"
            />
          </svg>
          <svg class="star-icon" viewBox="0 0 16 16">
            <path
              d="M8 .25a.75.75 0 0 1 .673.418l1.882 3.815 4.21.612a.75.75 0 0 1 .416 1.279l-3.046 2.97.719 4.192a.75.75 0 0 1-1.088.791L8 12.347l-3.766 1.98a.75.75 0 0 1-1.088-.79l.72-4.194L.818 6.374a.75.75 0 0 1 .416-1.28l4.21-.611L7.327.668A.75.75 0 0 1 8 .25z"
            />
          </svg>
          <span class="star-text">æœ¬ä¼˜åŒ–ç‰ˆä»“åº“</span>
        </a>

        <!-- Bç«™ç•ªå‰§é“¾æ¥ï¼ˆå¸¦è¾‰å…‰æ•ˆæœï¼‰ -->
        <a
          class="repo-link bili-link"
          href="https://www.bilibili.com/bangumi/play/ss29308"
          target="_blank"
          rel="noopener"
          title="ã€ŠBanG Dream! ç¬¬ä¸‰å­£ã€‹ - å…ƒç¥–è¿·ä½ åŠ¨ç”»"
        >
          <svg class="play-icon" viewBox="0 0 24 24" fill="currentColor">
            <path d="M8 5v14l11-7z"/>
          </svg>
          <span class="star-text">ç¬¬19é›†:ç®±ä¸­ç±³æ­‡å°”</span>
        </a>
      </div>

      <div id="board"></div>

      <div id="control-panel">
        <!-- å›åˆæ•°è®¾ç½®åŒºåŸŸ -->
        <div id="round-setup">
          <label for="total-rounds-input">æ€»å›åˆ(1-10)</label>
          <input type="number" id="total-rounds-input" min="1" max="10" value="1" step="1">
          <button id="set-rounds-btn" onclick="applyTotalRounds()">è®¾ç½®</button>
        </div>

        <div id="round-display">å›åˆ: 1/1</div>
        <div id="step-label">æ­¥ æ•°</div>
        <div id="step-display">0</div>
        <button class="btn" id="btn-reset" onclick="resetGame()">é‡ ç½®</button>
        <button class="btn" id="btn-hint" onclick="getHint()">æ ç¤º</button>
      </div>
    </div>

    <div id="victory-overlay">
      <div id="victory-box">
        <h2>ğŸ‰ æ­å–œï¼å…¨éƒ¨é€šå…³ï¼</h2>
        <p>ç±³æ­‡å°”æˆåŠŸé€ƒå‡º <span id="victory-total-rounds">0</span> æ¬¡ï¼æ€»æ­¥æ•° <span id="victory-steps">0</span></p>
        <button class="btn" onclick="resetGame()">å†æ¥ä¸€å±€</button>
      </div>
    </div>

    <script>
      // ============================================================
      // æ•°æ®æ¨¡å‹
      // ============================================================
      const COLS = 4;
      const ROWS = 5;
      const GAP = 2;
      const MAX_ROUNDS = 10; // æœ€å¤§å…è®¸å›åˆæ•°

      const TYPES = {
        "2x2": [2, 2],
        "1x2": [1, 2],
        "2x1": [2, 1],
        "1x1": [1, 1],
      };

      // ----- ä¸‰ä¸ªä¸åŒå›åˆçš„å¸ƒå±€ï¼ˆå¾ªç¯ä½¿ç”¨ï¼‰-----
      const LAYOUTS = [
        [ // å¸ƒå±€1
          { id: "michelle", type: "2x2", x: 1, y: 0, img: "images/michelle.png" },
          { id: "nyamu", type: "1x2", x: 0, y: 0, img: "images/nyamu.png" },
          { id: "moca", type: "1x2", x: 3, y: 0, img: "images/moca.png" },
          { id: "arisa", type: "1x2", x: 0, y: 2, img: "images/arisa.png" },
          { id: "yukina", type: "2x1", x: 1, y: 2, img: "images/yukina.png" },
          { id: "eve", type: "1x2", x: 3, y: 2, img: "images/eve.png" },
          { id: "saya", type: "1x1", x: 1, y: 3, img: "images/saya.png" },
          { id: "box", type: "1x1", x: 2, y: 3, img: "images/box.png" },
          { id: "otae", type: "1x1", x: 0, y: 4, img: "images/otae.png" },
          { id: "tsukushi", type: "1x1", x: 3, y: 4, img: "images/tsukushi.png" },
        ],
        [ // å¸ƒå±€2
          { id: "michelle", type: "2x2", x: 1, y: 0, img: "images/michelle.png" },
          { id: "nyamu", type: "1x2", x: 0, y: 0, img: "images/nyamu.png" },
          { id: "moca", type: "1x2", x: 3, y: 0, img: "images/moca.png" },
          { id: "arisa", type: "1x2", x: 0, y: 2, img: "images/arisa.png" },
          { id: "yukina", type: "2x1", x: 1, y: 2, img: "images/yukina.png" },
          { id: "eve", type: "1x2", x: 3, y: 2, img: "images/eve.png" },
          { id: "saya", type: "1x1", x: 2, y: 3, img: "images/saya.png" },
          { id: "box", type: "1x1", x: 1, y: 3, img: "images/box.png" },
          { id: "otae", type: "1x1", x: 0, y: 4, img: "images/otae.png" },
          { id: "tsukushi", type: "1x1", x: 3, y: 4, img: "images/tsukushi.png" },
        ],
        [ // å¸ƒå±€3
          { id: "michelle", type: "2x2", x: 1, y: 0, img: "images/michelle.png" },
          { id: "nyamu", type: "1x2", x: 0, y: 0, img: "images/nyamu.png" },
          { id: "moca", type: "1x2", x: 3, y: 0, img: "images/moca.png" },
          { id: "arisa", type: "1x2", x: 0, y: 2, img: "images/arisa.png" },
          { id: "yukina", type: "2x1", x: 1, y: 2, img: "images/yukina.png" },
          { id: "eve", type: "1x2", x: 3, y: 2, img: "images/eve.png" },
          { id: "saya", type: "1x1", x: 1, y: 3, img: "images/saya.png" },
          { id: "box", type: "1x1", x: 2, y: 3, img: "images/box.png" },
          { id: "otae", type: "1x1", x: 3, y: 4, img: "images/otae.png" },
          { id: "tsukushi", type: "1x1", x: 0, y: 4, img: "images/tsukushi.png" },
        ]
      ];

      // å½“å‰æ¸¸æˆçŠ¶æ€
      let blocks = [];
      let steps = 0;
      let solving = false;
      let currentRound = 1;           // å½“å‰ç¬¬å‡ å›åˆ
      let totalRounds = 1;             // æ€»å…±éœ€è¦å®Œæˆçš„å›åˆæ•°ï¼ˆé»˜è®¤1ï¼‰

      // æç¤ºç³»ç»ŸçŠ¶æ€
      let hintSolution = null;
      let hintIndex = 0;
      let hintStateKey = null;
      let hintWorker = null;
      let hintComputing = false;

      // æ‹–æ‹½çŠ¶æ€
      let dragState = null;

      // éŸ³æ•ˆå¼€å…³å˜é‡
      let eveSoundEnabled = true;      // é»˜è®¤å¼€å¯

      // DOM å¼•ç”¨
      const boardEl = document.getElementById("board");
      const stepDisplay = document.getElementById("step-display");
      const roundDisplay = document.getElementById("round-display");
      const victoryOverlay = document.getElementById("victory-overlay");
      const victorySteps = document.getElementById("victory-steps");
      const victoryTotalRounds = document.getElementById("victory-total-rounds");
      const boardBgImg = document.getElementById("board-bg-img");
      const totalRoundsInput = document.getElementById("total-rounds-input");
      const eveSoundToggle = document.getElementById("eve-sound-toggle");

      // ç›‘å¬éŸ³æ•ˆå¼€å…³
      if (eveSoundToggle) {
        eveSoundToggle.addEventListener('change', function(e) {
          eveSoundEnabled = e.target.checked;
        });
      }

      // ============================================================
      // å·¥å…·å‡½æ•°
      // ============================================================
      function deepCloneLayout(layout) {
        return layout.map((b) => ({ ...b }));
      }

      // æ ¹æ®å›åˆæ•°è·å–å¯¹åº”çš„å¸ƒå±€ï¼ˆ1,2,3å¾ªç¯ï¼‰
      function getLayoutForRound(round) {
        const index = (round - 1) % LAYOUTS.length; // 0,1,2,0,1,2,...
        return deepCloneLayout(LAYOUTS[index]);
      }

      // æ ¹æ®å›åˆæ•°æ›´æ–°æ£‹ç›˜èƒŒæ™¯å›¾ (board1.png, board2.png, board3.png å¾ªç¯)
      function updateBoardBackground(round) {
        if (boardBgImg) {
          const bgIndex = (round - 1) % 3 + 1; // 1,2,3å¾ªç¯
          boardBgImg.src = `images/board${bgIndex}.png`;
        }
      }

      function getCellSize() {
        const boardRect = boardEl.getBoundingClientRect();
        return {
          cellW: boardRect.width / COLS,
          cellH: boardRect.height / ROWS,
        };
      }

      // ============================================================
      // æ¸²æŸ“
      // ============================================================
      function renderBoard() {
        boardEl.innerHTML = "";
        const { cellW, cellH } = getCellSize();

        blocks.forEach((block) => {
          const [w, h] = TYPES[block.type];
          const el = document.createElement("div");
          el.className = "block";
          el.id = "block-" + block.id;
          el.style.width = cellW * w - GAP * 2 + "px";
          el.style.height = cellH * h - GAP * 2 + "px";
          el.style.left = block.x * cellW + GAP + "px";
          el.style.top = block.y * cellH + GAP + "px";

          const img = document.createElement("img");
          img.src = block.img;
          img.alt = block.id;
          img.draggable = false;
          el.appendChild(img);

          // é¼ æ ‡æ‹–æ‹½
          el.addEventListener("mousedown", (e) => {
            e.preventDefault();
            startDrag(block.id, e.clientX, e.clientY);
          });

          // è§¦æ‘¸æ‹–æ‹½
          el.addEventListener("touchstart", (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            startDrag(block.id, touch.clientX, touch.clientY);
          });

          boardEl.appendChild(el);
        });

        // æ›´æ–°å›åˆæ˜¾ç¤º
        roundDisplay.textContent = `å›åˆ: ${currentRound}/${totalRounds}`;
      }

      function updateBlockPosition(block) {
        const { cellW, cellH } = getCellSize();
        const el = document.getElementById("block-" + block.id);
        if (!el) return;
        el.style.left = block.x * cellW + GAP + "px";
        el.style.top = block.y * cellH + GAP + "px";
      }

      // ============================================================
      // æ‹–æ‹½äº¤äº’
      // ============================================================
      function startDrag(blockId, startX, startY) {
        if (solving) return;
        const block = blocks.find((b) => b.id === blockId);
        if (!block) return;

        const el = document.getElementById("block-" + blockId);
        el.classList.add("dragging");

        dragState = {
          blockId,
          startX,
          startY,
          origGridX: block.x,
          origGridY: block.y,
          moved: false,
        };
      }

      function onDragMove(clientX, clientY) {
        if (!dragState) return;

        const { cellW, cellH } = getCellSize();
        const dx = clientX - dragState.startX;
        const dy = clientY - dragState.startY;

        const threshold = Math.min(cellW, cellH) * 0.2;

        if (dragState.moved) return;

        let moveDx = 0;
        let moveDy = 0;

        if (Math.abs(dx) > Math.abs(dy)) {
          if (dx > threshold) moveDx = 1;
          else if (dx < -threshold) moveDx = -1;
        } else {
          if (dy > threshold) moveDy = 1;
          else if (dy < -threshold) moveDy = -1;
        }

        if (moveDx !== 0 || moveDy !== 0) {
          const success = moveBlock(dragState.blockId, moveDx, moveDy);
          if (success) dragState.moved = true;
        }
      }

      function endDrag() {
        if (!dragState) return;
        const el = document.getElementById("block-" + dragState.blockId);
        if (el) el.classList.remove("dragging");
        dragState = null;
      }

      document.addEventListener("mousemove", (e) => onDragMove(e.clientX, e.clientY));
      document.addEventListener("mouseup", endDrag);
      document.addEventListener("touchmove", (e) => {
        if (dragState) {
          e.preventDefault();
          const touch = e.touches[0];
          onDragMove(touch.clientX, touch.clientY);
        }
      }, { passive: false });
      document.addEventListener("touchend", endDrag);
      document.addEventListener("touchcancel", endDrag);

      // ============================================================
      // éŸ³æ•ˆ
      // ============================================================
      let audioCtx = null;

      // æ™®é€šç§»åŠ¨éŸ³æ•ˆï¼ˆåˆæˆéŸ³ï¼‰
      function playMoveSound() {
        if (!audioCtx)
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const t = audioCtx.currentTime;
        const rand = (base, range) => base + (Math.random() - 0.5) * 2 * range;

        const bufLen = Math.floor(audioCtx.sampleRate * 0.04);
        const buf = audioCtx.createBuffer(1, bufLen, audioCtx.sampleRate);
        const data = buf.getChannelData(0);
        for (let i = 0; i < bufLen; i++) data[i] = Math.random() * 2 - 1;

        const noise = audioCtx.createBufferSource();
        noise.buffer = buf;

        const bandpass = audioCtx.createBiquadFilter();
        bandpass.type = "bandpass";
        bandpass.frequency.value = rand(2200, 300);
        bandpass.Q.value = rand(3.0, 0.8);

        const noiseGain = audioCtx.createGain();
        noiseGain.gain.setValueAtTime(rand(0.35, 0.05), t);
        noiseGain.gain.exponentialRampToValueAtTime(0.001, t + 0.04);

        noise.connect(bandpass);
        bandpass.connect(noiseGain);
        noiseGain.connect(audioCtx.destination);
        noise.start(t);

        const osc = audioCtx.createOscillator();
        const oscGain = audioCtx.createGain();
        osc.type = "sine";
        osc.frequency.setValueAtTime(rand(420, 40), t);
        osc.frequency.exponentialRampToValueAtTime(rand(150, 20), t + 0.05);
        oscGain.gain.setValueAtTime(rand(0.2, 0.03), t);
        oscGain.gain.exponentialRampToValueAtTime(0.001, t + 0.06);

        osc.connect(oscGain);
        oscGain.connect(audioCtx.destination);
        osc.start(t);
        osc.stop(t + 0.06);
      }

      // eve ä¸“å±éŸ³æ•ˆï¼ˆæ’­æ”¾å¤–éƒ¨æ–‡ä»¶ï¼‰
      function playEveSound() {
        try {
          const audio = new Audio('images/eve.mp3');
          audio.volume = 0.5;
          audio.play().catch(e => console.log('eveéŸ³æ•ˆæ’­æ”¾å¤±è´¥ï¼ˆå¯å¿½ç•¥ï¼‰', e));
        } catch (e) {
          console.log('eveéŸ³æ•ˆé”™è¯¯', e);
        }
      }

      // èƒœåˆ©éŸ³æ•ˆ
      function playVictorySound() {
        try {
          const audio = new Audio('images/victory.mp3');
          audio.volume = 0.5;
          audio.play().catch(e => console.log('èƒœåˆ©éŸ³æ•ˆæ’­æ”¾å¤±è´¥ï¼ˆå¯å¿½ç•¥ï¼‰', e));
        } catch (e) {
          console.log('èƒœåˆ©éŸ³æ•ˆé”™è¯¯', e);
        }
      }

      // ============================================================
      // ç¢°æ’æ£€æµ‹ä¸ç§»åŠ¨
      // ============================================================
      function buildGrid(blocksState) {
        const grid = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
        blocksState.forEach((b) => {
          const [w, h] = TYPES[b.type];
          for (let dy = 0; dy < h; dy++) {
            for (let dx = 0; dx < w; dx++) {
              grid[b.y + dy][b.x + dx] = b.id;
            }
          }
        });
        return grid;
      }

      function canMove(block, dx, dy, grid) {
        const [w, h] = TYPES[block.type];
        const nx = block.x + dx;
        const ny = block.y + dy;

        if (nx < 0 || ny < 0 || nx + w > COLS || ny + h > ROWS) return false;

        for (let r = 0; r < h; r++) {
          for (let c = 0; c < w; c++) {
            const occupant = grid[ny + r][nx + c];
            if (occupant !== null && occupant !== block.id) return false;
          }
        }
        return true;
      }

      // å¤„ç†å›åˆå®Œæˆï¼ˆç±³æ­‡å°”åˆ°è¾¾å‡ºå£ï¼‰
      function handleRoundComplete() {
        if (currentRound < totalRounds) {
          // è¿›å…¥ä¸‹ä¸€å›åˆ
          currentRound++;
          // æ›´æ–°èƒŒæ™¯å›¾
          updateBoardBackground(currentRound);
          // åŠ è½½ä¸‹ä¸€å›åˆçš„å¸ƒå±€ï¼ˆå¾ªç¯ï¼‰
          blocks = getLayoutForRound(currentRound);
          // é‡æ–°æ¸²æŸ“æ£‹ç›˜
          renderBoard();
          // æ¸…é™¤æç¤ºç¼“å­˜ï¼ˆæ–°å¸ƒå±€éœ€è¦é‡æ–°è®¡ç®—ï¼‰
          hintSolution = null;
          hintIndex = 0;
          hintStateKey = null;
          // æ›´æ–°å›åˆæ˜¾ç¤º
          roundDisplay.textContent = `å›åˆ: ${currentRound}/${totalRounds}`;
          // æ­¥æ•°ä¸æ¸…é›¶ï¼Œç´¯è®¡
        } else {
          // å·²å®Œæˆå…¨éƒ¨å›åˆï¼Œæ˜¾ç¤ºèƒœåˆ©å¼¹çª—
          victorySteps.textContent = steps;
          victoryTotalRounds.textContent = totalRounds;
          victoryOverlay.classList.add("show");
          playVictorySound();
        }
      }

      function moveBlock(blockId, dx, dy) {
        const block = blocks.find((b) => b.id === blockId);
        if (!block) return false;

        const grid = buildGrid(blocks);
        if (!canMove(block, dx, dy, grid)) return false;

        block.x += dx;
        block.y += dy;
        updateBlockPosition(block);

        // æ’­æ”¾éŸ³æ•ˆï¼ševe æ ¹æ®å¼€å…³å†³å®šæ˜¯å¦æ’­æ”¾
        if (block.id === 'eve') {
          if (eveSoundEnabled) {
            playEveSound();
          }
        } else {
          playMoveSound();
        }

        if (!solving) {
          // ç”¨æˆ·æ‰‹åŠ¨ç§»åŠ¨ï¼Œä½¿æç¤ºç¼“å­˜å¤±æ•ˆ
          hintSolution = null;
          hintIndex = 0;
          hintStateKey = null;
          steps++;
          stepDisplay.textContent = steps;
        }

        // èƒœåˆ©åˆ¤å®šï¼šä»…å½“ç±³æ­‡å°”åˆ°è¾¾å‡ºå£ (1,3) æ—¶è§¦å‘å›åˆå¤„ç†
        if (block.id === "michelle" && block.x === 1 && block.y === 3) {
          setTimeout(handleRoundComplete, 300);
        }

        return true;
      }

      // ============================================================
      // åº”ç”¨è‡ªå®šä¹‰æ€»å›åˆæ•°
      // ============================================================
      function applyTotalRounds() {
        let newTotal = parseInt(totalRoundsInput.value, 10);
        if (isNaN(newTotal) || newTotal < 1) newTotal = 1;
        if (newTotal > MAX_ROUNDS) newTotal = MAX_ROUNDS;
        totalRoundsInput.value = newTotal; // å›æ˜¾ä¿®æ­£åçš„å€¼
        totalRounds = newTotal;
        // é‡ç½®æ¸¸æˆï¼ˆä»ç¬¬ä¸€å›åˆå¼€å§‹ï¼‰
        resetGame();
      }

      // ============================================================
      // é‡ç½®
      // ============================================================
      function resetGame() {
        solving = false;
        steps = 0;
        stepDisplay.textContent = "0";
        currentRound = 1;
        roundDisplay.textContent = `å›åˆ: ${currentRound}/${totalRounds}`;
        victoryOverlay.classList.remove("show");
        blocks = getLayoutForRound(1); // ä»ç¬¬ä¸€å…³å¼€å§‹
        updateBoardBackground(1);

        hintSolution = null;
        hintIndex = 0;
        hintStateKey = null;
        hintComputing = false;
        if (hintWorker) {
          hintWorker.terminate();
          hintWorker = null;
        }
        const btnHint = document.getElementById("btn-hint");
        if (btnHint) {
          btnHint.disabled = false;
          btnHint.textContent = "æ ç¤º";
        }
        renderBoard();
      }

      // ============================================================
      // æç¤ºç³»ç»Ÿ (Web Worker BFS) - ä»£ç ä¸ä¹‹å‰å®Œå…¨ç›¸åŒ
      // ============================================================
      const workerCode = `
        const COLS = 4, ROWS = 5;
        const TYPES = { '2x2': [2,2], '1x2': [1,2], '2x1': [2,1], '1x1': [1,1] };
        // ç±»å‹ç¼–ç : 0=ç©º, 1=1x1, 2=1x2(å ä¸ŠåŠ), 3=1x2(å ä¸‹åŠ), 4=2x1(å å·¦åŠ), 5=2x1(å å³åŠ),
        //           6=michelleå·¦ä¸Š, 7=michelleå³ä¸Š, 8=michelleå·¦ä¸‹, 9=michelleå³ä¸‹

        function encodeState(bs) {
          const g = new Uint8Array(20);
          for (const b of bs) {
            const [w, h] = TYPES[b.type];
            if (b.id === 'michelle') {
              g[b.y * COLS + b.x] = 6;
              g[b.y * COLS + b.x + 1] = 7;
              g[(b.y + 1) * COLS + b.x] = 8;
              g[(b.y + 1) * COLS + b.x + 1] = 9;
            } else if (b.type === '1x1') {
              g[b.y * COLS + b.x] = 1;
            } else if (b.type === '1x2') {
              g[b.y * COLS + b.x] = 2;
              g[(b.y + 1) * COLS + b.x] = 3;
            } else if (b.type === '2x1') {
              g[b.y * COLS + b.x] = 4;
              g[b.y * COLS + b.x + 1] = 5;
            }
          }
          return String.fromCharCode.apply(null, g);
        }

        function buildGrid(bs) {
          const grid = [];
          for (let r = 0; r < ROWS; r++) grid[r] = new Array(COLS).fill(-1);
          for (let i = 0; i < bs.length; i++) {
            const b = bs[i];
            const [w, h] = TYPES[b.type];
            for (let dy = 0; dy < h; dy++)
              for (let dx = 0; dx < w; dx++)
                grid[b.y + dy][b.x + dx] = i;
          }
          return grid;
        }

        function canMove(b, dx, dy, grid, idx) {
          const [w, h] = TYPES[b.type];
          const nx = b.x + dx, ny = b.y + dy;
          if (nx < 0 || ny < 0 || nx + w > COLS || ny + h > ROWS) return false;
          for (let r = 0; r < h; r++)
            for (let c = 0; c < w; c++) {
              const occ = grid[ny + r][nx + c];
              if (occ !== -1 && occ !== idx) return false;
            }
          return true;
        }

        self.onmessage = function(e) {
          const startBlocks = e.data;
          const visited = new Set();
          const startKey = encodeState(startBlocks);
          visited.add(startKey);

          const queue = [startBlocks.map(b => ({...b}))];
          const parent = [null];
          let head = 0;

          const dirs = [[0,-1],[0,1],[-1,0],[1,0]];

          while (head < queue.length) {
            const state = queue[head];
            const michIdx = state.findIndex(b => b.id === 'michelle');

            if (state[michIdx].x === 1 && state[michIdx].y === 3) {
              const path = [];
              let cur = head;
              while (parent[cur] !== null) {
                const p = parent[cur];
                path.unshift({ id: queue[p.stateIdx][p.blockIdx].id, dx: p.dx, dy: p.dy });
                cur = p.stateIdx;
              }
              self.postMessage({ success: true, moves: path });
              return;
            }

            const grid = buildGrid(state);

            for (let bi = 0; bi < state.length; bi++) {
              const b = state[bi];
              for (const [dx, dy] of dirs) {
                if (!canMove(b, dx, dy, grid, bi)) continue;
                const ns = state.map(x => ({...x}));
                ns[bi] = {...ns[bi], x: ns[bi].x + dx, y: ns[bi].y + dy};
                const key = encodeState(ns);
                if (visited.has(key)) continue;
                visited.add(key);
                queue.push(ns);
                parent.push({ stateIdx: head, blockIdx: bi, dx, dy });
              }
            }
            head++;
          }

          self.postMessage({ success: false });
        };
      `;

      function getHint() {
        if (solving || hintComputing) return;

        const btnHint = document.getElementById("btn-hint");

        // å¦‚æœæœ‰ç¼“å­˜çš„è§£ä¸”è¿˜æœ‰åç»­æ­¥éª¤ï¼Œç›´æ¥æ‰§è¡Œ
        if (hintSolution && hintIndex < hintSolution.length) {
          const move = hintSolution[hintIndex];
          solving = true;
          moveBlock(move.id, move.dx, move.dy);
          steps++;
          stepDisplay.textContent = steps;
          solving = false;
          hintIndex++;
          if (hintIndex >= hintSolution.length) {
            hintSolution = null;
            hintStateKey = null;
          }
          return;
        }

        // éœ€è¦é‡æ–°è®¡ç®—
        hintComputing = true;
        btnHint.disabled = true;
        btnHint.textContent = "æ€è€ƒä¸­â€¦";

        const blob = new Blob([workerCode], { type: "application/javascript" });
        const url = URL.createObjectURL(blob);
        hintWorker = new Worker(url);

        hintWorker.onmessage = function (e) {
          URL.revokeObjectURL(url);
          hintWorker = null;
          hintComputing = false;
          btnHint.disabled = false;
          btnHint.textContent = "æ ç¤º";

          if (e.data.success && e.data.moves.length > 0) {
            hintSolution = e.data.moves;
            hintIndex = 0;
            // ç«‹å³æ‰§è¡Œç¬¬ä¸€æ­¥
            const move = hintSolution[hintIndex];
            solving = true;
            moveBlock(move.id, move.dx, move.dy);
            steps++;
            stepDisplay.textContent = steps;
            solving = false;
            hintIndex++;
            if (hintIndex >= hintSolution.length) {
              hintSolution = null;
              hintStateKey = null;
            }
          }
        };

        hintWorker.onerror = function () {
          URL.revokeObjectURL(url);
          hintWorker = null;
          hintComputing = false;
          btnHint.disabled = false;
          btnHint.textContent = "æ ç¤º";
          alert("æ±‚è§£å‡ºé”™ï¼Œè¯·é‡è¯•");
        };

        // å‘é€å½“å‰çŠ¶æ€ç»™ Worker
        hintWorker.postMessage(deepCloneLayout(blocks));
      }

      // ============================================================
      // å¯åŠ¨
      // ============================================================
      window.addEventListener("load", () => {
        resetGame(); // æ­¤æ—¶ totalRounds ä¸ºé»˜è®¤1
      });

      window.addEventListener("resize", () => {
        renderBoard();
      });
    </script>
  </body>
</html>